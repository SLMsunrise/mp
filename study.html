总结各学习方法、技巧、技术

1. for in循环 for(let i in arr){console.log(arr[i])}//输出数组中各值

2. Array.from(new Set(zjtypeNuber));//使用es6的set方法对数组去重

3. 绘制不同颜色的三角形且重合在一起
   HTML:<i class="sjx"></i>
   CSS:.sjx {
          display: flex;
          content: '';
          border-width: 8px 8px 0px 8px;
          border-style: solid;
          border-color: #00ffff transparent transparent transparent;
          width: 0;
          height: 0;
          position: relative;
          margin: 0 auto;
          margin-top: -5px;
        }
        .sjx::before {
          display: flex;
          content: '';
          border-width: 5px 5px 0px 5px;
          border-style: solid;
          border-color: #000000 transparent transparent transparent;
          width: 0;
          height: 0;
          position: relative;
          margin-top: -8px;
          margin-left: -5px;
        }
        .sjx::after {
          display: flex;
          content: '';
          border-width: 2px 2px 0px 2px;
          border-style: solid;
          border-color: #00ffff transparent transparent transparent;
          width: 0;
          height: 0;
          position: relative;
          margin-top: -8px;
          margin-left: -7px;
        }

4. 把数组变变为一个对象数组
        var arr = [1,2,3,4,5];
        var sa={}
        arr.forEach(function(value,index) {
            sa[index] ={"hostIp":value};  
        })
        console.log(sa)

5. 三元运算符前面是一个条件语句可以很长，根据不同的数据类型显示不同的图标
   <span v-if="item.devInfo && item.devInfo.devType && item.devInfo.devType==1?true:false"><i class="engine shouji"></i></span>

6. jquery中：向下展开div,并且执行一个回调函数
   $(".flip").click(function(){
    $(".panel").slideToggle("slow",function(){
      alert("23");//
    });
  });

7. jquery中：获取dom元素的值==>$("#slm");
      text() - 设置或返回所选元素的文本内容
      html() - 设置或返回所选元素的内容（包括 HTML 标记）
      val() - 设置或返回表单字段的值
      attr("属性字段") - 返回当前DOM的属性字段的值
      attr("属性字段","新的值") - 设置新的属性值 
      回调函数由两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串。

8. jquery中：添加新的 HTML 内容==>$("#slm");
      append() - 在被选元素的结尾插入内容
      prepend() - 在被选元素的开头插入内容
      after() - 在被选元素之后插入内容
      before() - 在被选元素之前插入内容

9. jquery中：删除HTML内容
      remove() - 删除被选元素（及其子元素）
      empty() - 从被选元素中删除子元素
      区别是：remove是连自己都删，empty是除自己外的所有子元素

10.jquery中：对css进行操作
      addClass() - 向被选元素添加一个或多个类
      removeClass() - 从被选元素删除一个或多个类
      toggleClass() - 对被选元素进行添加/删除类的切换操作
      css() - 设置或返回样式属性

11. css中的一种宽高写法，可保持页面缩放/放大时，自适应
    width: calc(100% - 105px);
    height: calc(100% - 105px);

12. 弹性布局Flex：不考虑低版本IE兼容的情况下，常用的弹性布局多为居中，两边对齐
    .box{                  
         display: inline-flex/flex;    //指定该元素为弹性布局
         flex-direction:row | row-reverse | column | column-reverse;    //指定元素内的子元素主轴的显示方向，从上到下，从下到上，从左到右（常用），从右到左
         flex-wrap: nowrap | wrap | wrap-reverse;       //元素换行，默认不换行，wrap表示换行后的默认排序，第三种是倒着来，把第二行的显示在第一行
         justify-content: flex-start | flex-end | center | space-between | space-around;//对齐方式分别为：左对齐、右对齐、居中、两端靠拢对齐、两端间隔相等
         flex-flow:属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap
         align-items: flex-start | flex-end | center | baseline | stretch; //flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度
     }
    .item{
         order: <integer>; //属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。
         flex-grow: <number>; //flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
     }

13. div标签的全屏和退出全屏
        （1）. dom元素添加事件
         <div id="contain"></div>
         JavaScript：
         <button  οnclick="showFullScreen()">dom全屏</button>
         <button  οnclick="exitFullScreen()">退出全屏</button>

         vue:
         <button  @click="showFullScreen()">全屏</button>
         <button  @click="exitFullScreen()">退出全屏</button>
            
         （2）.获取当前元素进行dom全屏操作
            function showFullScreen(){
                   var full=document.getElementById("contain");
                   launchIntoFullscreen(full);
               }

               function exitFullScreen() {
                    exitFullscreen();
               }
         （3）.标签全屏和退出全屏方法封装
            //div标签全屏方法
            function launchIntoFullscreen(element) {
                if(element.requestFullscreen){
                    element.requestFullscreen();
                } else if(element.mozRequestFullScreen) {
                    element.mozRequestFullScreen();
                } else if(element.webkitRequestFullscreen) {
                    element.webkitRequestFullscreen();
                } else if(element.msRequestFullscreen) {
                    element.msRequestFullscreen();
                }
            }

            //退出div标签全屏方法
            function exitFullscreen() {
                if(document.exitFullscreen) {
                    document.exitFullscreen();
                } else if(document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if(document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
            }
            
14. jquery中：向上查找DOM
            parent()            //返回被选元素的直接父元素,该方法只会向上一级对 DOM 树进行遍历
            parents()          //返回被选元素的所有祖先元素，它一路向上直到文档的根元素;可以使用可选参数来过滤对祖先元素的搜索
            parentsUntil()    //返回介于两个给定元素之间的所有祖先元素
            
15. jquery中：向下查找DOM
            children()     //返回被选元素的所有直接子元素;可以使用可选参数来过滤对子元素的搜索
            find()         //返回被选元素的后代元素，一路向下直到最后一个后代;可以使用可选参数来过滤对子元素的搜索

16. jquery中：在DOM树中水平查找
            siblings()     //返回被选元素的所有同胞元素;可以使用可选参数来过滤对同胞元素的搜索
            next()         //返回被选元素的下一个同胞元素
            nextAll()      //返回被选元素的所有跟随的同胞元素
            nextUntil()    //返回介于两个给定参数之间的所有跟随的同胞元素
            prev()         //向前
            prevAll()      //向前
            prevUntil()    //向前
            
17. jquery中：缩小过滤查找
            first()     //返回被选元素的首个元素
            last()      //返回被选元素的最后一个元素
            eq()        //返回被选元素中带有指定索引号的元素
            filter()    //允许您规定一个标准,可以理解为查找相同或是指定的元素,这个元素的条件由你定义
            not()       //返回不匹配标准的所有元素
            
18. jquery中：ajax==>在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示
            (1).var xmlhttp;                       //创建兼容各版本的Ajax请求对象
               if (window.XMLHttpRequest){      
                   xmlhttp=new XMLHttpRequest();   // code for IE7+, Firefox, Chrome, Opera, Safari
               }else{      
                   xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");// code for IE6, IE5
               }
            
            (2).xmlhttp.open("请求类型(post/get)","请求地址(url)",是否异步(true/false)); //括号不要
                xmlhttp.send();     //将请求发送到服务器
                * post和get的区别：与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用
                  以下情况建议post：
                    * 无法使用缓存文件(更新服务器上的文件或数据库)
                    * 向服务器发送大量数据(POST 没有数据量限制)
                    * 发送包含未知字符的用户输入时,POST 比 GET 更稳定也更可靠
            
            (3).xmlhttp.readyState==4 && xmlhttp.status==200            //该代码意味请求成功
               onreadystatechange==>存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。
               readyState存有XMLHttpRequest 的状态。从 0 到 4 发生变化。
                  0: 请求未初始化
                  1: 服务器连接已建立
                  2: 请求已接收
                  3: 请求处理中
                  4: 请求已完成，且响应已就绪
               status	
                  200: "OK"
                  404: 未找到页面

            
                xmlhttp.responseText  //返回的数据集,返回如下的两种数据集
                responseText	获得字符串形式的响应数据。
                responseXML	获得 XML 形式的响应数据。

19. jquery中： AJAX load()      //load() 方法从服务器加载数据，并把返回的数据放入被选元素中
               $(selector).load(URL,data,callback);
               回调函数可设置以下参数==>
               responseTxt - 包含调用成功时的结果内容
               statusTXT - 包含调用的状态
               xhr - 包含 XMLHttpRequest 对象
            
20. jquery中：get() 和 post() 方法用于通过 HTTP GET 或 POST 请求从服务器请求数据
            (1) $.get(URL,callback)
            (2) $.post(URL,data,callback);
            
21. jquery中:常用的方法集合
    (1). bind() 方法向被选元素添加一个或多个事件处理程序，以及当事件发生时运行的函数,1.7版本之后建议使用on()方法
    (2). blur() 当元素失去焦点时发生 blur 事件常和 focus()方法连用
    (3). change() 元素的值改变时发生 change 事件,常用于表单字段 
    (4). click() 触发 click(单击) 事件        
    (5). dblclick() 双击事件
    (6). event.currentTarget 属性是在事件冒泡阶段内的当前 DOM 元素，通常等于 this
    (7). event.data 属性包含当前执行的处理程序被绑定时传递到事件方法的可选数据
    (8). event.target 属性返回哪个 DOM 元素触发了事件      
            
22. 获取当前点击的li标签的下标：$(event.target).index();
            
23. 当元素隐藏事，图标向下，点击后，图标向上：
            showMessage(event){      //定义一个鼠标事件方法，在需要点击的地方调用
               $(event.target).children().toggleClass("newssjxparentbefore");  
            }
            
24. jquery中：获取div到屏幕左侧的距离
            let screenwidth=$('#mynetwork_ly').offset().left;
            
25. vue中：基本的vuex用法
       (1).项目结构中的store文件夹下新建index.js文件，内容如下
            import Vue from 'vue'            //引入vue
            import Vuex from 'vuex'          //引入vuex
            Vue.use(Vuex)                    //使用vuex
            export default new Vuex.Store({  //new一个vuex的store
              state: {                       //state是自定义的一些变量，需要用来保存数据
                  prames:null                //例如一个null值
              },
              mutations: {                   //mutations是用来触发事件，相当于方法
                savePrames(state,prames){    //方法一、prames参数就是传过来的值
                  state.prames = prames;     //把值赋给state中的变量
                },
              },
              actions: {                     
            
              },
              modules: {
            
              }
            })
         
        (2).在应用程序主入口index.js中
            import store from './store/index'      //刚刚在store中新建的js
            new Vue({
              el: '#app',
              router,
              store,                               //这个就是new的仓名
              render: h => h(App)
            });
            
         (3).传值,直接在某个组件中，打印一个事件或是某种方法进行传值
            this.$store.commit('savePrames',prames)   //commit中的两个参数分别指：store文件夹走js下定义在mutations下的方法名、和当前组件要传到store中的值
            
         (4).用值,在另一个组件用刚刚组件传到store中的值
            this.parameter=this.$store.state.prames   //parameter是当前组件定义的变量,后面的就是把store中的值取出来进行赋值
            console.log(that.parameter);//HHH这个就是veux传过来的东西呀，自定义配置参数
/****************************************上述方法只是最简单的使用,后续会更新更复杂的应用*****************************************************************/
 
26. vue中：父组件主动获取子组件的数据和方法            
         (1).<headerchild ref="headerChild"></headerchild>  //调用子组件的时候 定义一个ref,headerchild是子组件
         (2).this.$refs.headerChild.属性 //在父组件里面通过  //headerChild是子组件
             this.$refs.headerChild.方法 //就是这么简单，我开始也不信
    vue中：子组件主动获取父组件的数据和方法
         (1).this.$parent.属性        //在子组件中直接使用即可
             this.$parent.方法   
            
27. vue中：侦听子组件数据变动
         <hostScanlist :ScanPortList="ScanPortList"></hostScanlist>//父组件中定义属性
         子组件中就行侦听：
         watch:{//监听
              ScanPortList:{
                  immediate:true,
                      handler(newVal,oldVal) {
                          console.log(newVal,oldVal)
                          this.ScanPortListArr = newVal
                          this.portScan()//监听数据变动就执行这个方法
                      },
                  deep:true,//深度监听
              }
        },
   
28. vue中：使用vuex时，传递的数据刷新后丢失，采用sessionstorage方式存储数据
         (1).在store中的index.js中加上如下的sessionStorage方法
               function sessionStorage (state) {
                    window.sessionStorage.setItem("store",JSON.stringify(state));
               }     
         (2).在export default new Vuex.Store({})下的mutations中定义:
               savePrames(state,prames){
                  state.prames = prames;
                  sessionStorage(state);   //数据存储为sessionStorage中
               },
         (3).在数据传递到的子组件或组件的created中:
               created () {
                    const that=this;
                    //在页面加载时读取localStorage里的状态信息
                    sessionStorage.getItem("store") && this.$store.replaceState(Object.assign(this.$store.state,JSON.parse(sessionStorage.getItem("store"))));
                    //在页面刷新时将vuex里的信息保存到localStorage里
                    window.addEventListener("beforeunload",()=>{
                        sessionStorage.setItem("store",JSON.stringify(this.$store.state))
                    })
                },
          * 注意: vuex中的数据最好的方法应该放在计算属性中去取     
            computed: {
                prames() {
                    return this.$store.state.prames
                }
             },  
            
29. css中：定义呼吸灯的效果
            .largit{
                /* IE10、Firefox and Opera，IE9以及更早的版本不支持 */
                animation-name: breath;                         /* 动画名称 */
                animation-duration: 3s;                         /* 动画时长3秒 */
                animation-timing-function: ease-in-out;         /* 动画速度曲线：以低速开始和结束 */
                animation-iteration-count: infinite;            /* 播放次数：无限 */
                /* Safari and Chrome */
                -webkit-animation-name: breath;                 /* 动画名称 */
                -webkit-animation-duration: 3s;                 /* 动画时长3秒 */
                -webkit-animation-timing-function: ease-in-out; /* 动画速度曲线：以低速开始和结束 */
                -webkit-animation-iteration-count: infinite;    /* 播放次数：无限 */
            }

            /* 呼吸灯 */
            @keyframes breath {
                from { opacity: 0.3; }                          /* 动画开始时的不透明度 */
                50%  { opacity:   1; }                          /* 动画50% 时的不透明度 */
                to   { opacity: 0.3; }                          /* 动画结束时的不透明度 */    
            }
            @-webkit-keyframes breath {
                from { opacity: 0.3; }
                50%  { opacity:   1; }
                to   { opacity: 0.3; }
            }

30. vue中异步数据获取放入data使用或是父组件调用子组件的异步数据
     (1) that.$emit("listNumber",that.nubmberList)       //listNubmer为父组件接收的变量 that.nubmberList为组件要传的值
     (2) <SmartData @listNumber="listNumberX"></SmartData> //父组件予用子组件时，绑定监听的方法       
     (3) watch:{           //监听父组件中接收的变量
            listNumber: {
              handler (newVal, oldVal) {
                this.listNumber = newVal
              },
              deep: true,
              immediate: true
            },
          },       
      (4) listNumberX(data){     //定义一个方法用于接收子组件传递的数据
               this.listNumber=data
          },      
    
            
31. 查看控制台代理配置npm config list    
     删除npm config delete proxy     
     npm install --save-dev @babel/core
     $ npm audit fix      //扫描您的项目中的漏洞，并自动安装任何兼容更新到易受攻击的依赖项
     $ npm audit --json   //获取JSON格式的详细审核报告
            
32. v-for的双重循环
    <ul v-for="(item,index) in list" :key="index">
       <li>
          {{ item.name }}
          <ul v-for="(i,cindex) in list[index].chrildList" :key="cindex">
              <li>{{ i.chrildName }}</li>
          </ul>
       </li>
    </ul>

33. 取浏览器中的localStrorage的数据，常用于用户信息等
     const data1 = JSON.parse(localStorage.getItem('USER_MESSAGE'))  //取localstorage中用户的数据
     console.log(data1.nickName);           

34. localStorage、sessionStorage操作
      1、localStorage.setItem(key,value) // 保存数据
      2、localStorage.getItem(key)       // 获取数据
      3、localStorage.removeItem(key)    // 删除数据
      4、localStorage.clear();           // 删除全部数据
            
35. 当需要多次遍历数组，对其赋值时，先判断没有数据时，再添加 
      var slm=[];
      var skb={a:"2",b:"4",c:"6",d:"8"}
      for(let i in skb){
      console.log(skb[i])
          if(slm.length==0){
              slm.push(skb[i])
             }else{
              slm=slm.concat(skb[i])
           }
      }
            
36. vue中动态绑定属性
      box-shadow: 1px 0 0px #010910, 2px 0 0 #404f5f;
      :href="";
      :style="{opacity:largitHideTwo==2?1:0.5}";
      :class="{'fontHover':steup>=320 && steup<=322}"
            
37. 中间深，两边渐隐的分割线
   .user-name[data-v-69779587]::before {
       content: "";
       position: absolute;
       top: 0;
       left: 0;
       display: block;
       height: 58px;
       width: 1px;
       background: linear-gradient(80deg, #0b595f, #00ffff, #0b595f);
   }
         
 38.         
         
